#!/usr/bin/env node
/**
 * epicdeps
 *
 * Generate a Mermaid dependency graph for child tickets in a Jira epic.
 *
 * Usage:
 *   epicdeps EPIC-123
 *   epicdeps EPIC-123 --output epic-deps.mmd
 *
 * Jira instance:
 *   Defaults to https://elliptic.atlassian.net
 *   Override with JIRA_BASE_URL if needed.
 *
 * Auth:
 *   Preferred:
 *     JIRA_EMAIL=you@company.com
 *     JIRA_TOKEN=atlassian_api_token
 */

"use strict";

const fs = require("node:fs/promises");
const os = require("node:os");
const path = require("node:path");
const { execFile } = require("node:child_process");
const { promisify } = require("node:util");
const DEFAULT_JIRA_BASE_URL = "https://elliptic.atlassian.net";
const DEFAULT_JIRA_EMAIL = "joe.barnett@elliptic.co";
const execFileAsync = promisify(execFile);
const VALID_FORMATS = new Set(["markdown", "mermaid", "svg"]);

function parseArgs(argv) {
  const args = {
    epicKey: null,
    output: null,
    format: "markdown",
    help: false,
  };

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    if (arg === "-h" || arg === "--help") {
      args.help = true;
      continue;
    }
    if (arg === "-o" || arg === "--output") {
      const next = argv[i + 1];
      if (!next) {
        throw new Error("Missing value for --output");
      }
      args.output = next;
      i += 1;
      continue;
    }
    if (arg === "-f" || arg === "--format") {
      const next = argv[i + 1];
      if (!next) {
        throw new Error("Missing value for --format");
      }
      if (!VALID_FORMATS.has(next)) {
        throw new Error(
          `Invalid --format value: ${next}. Expected one of: markdown, mermaid, svg`
        );
      }
      args.format = next;
      i += 1;
      continue;
    }
    if (!args.epicKey) {
      args.epicKey = arg;
      continue;
    }
    throw new Error(`Unexpected argument: ${arg}`);
  }

  return args;
}

function usage() {
  return `Usage:
  epicdeps <EPIC_KEY> [--output <file>] [--format <markdown|mermaid|svg>]

Jira instance:
  Default: ${DEFAULT_JIRA_BASE_URL}
  Optional override: JIRA_BASE_URL

Authentication:
  JIRA_TOKEN required.
  Uses Basic auth with default email ${DEFAULT_JIRA_EMAIL}.
  Optional override: JIRA_EMAIL

Output:
  Default format: markdown (fenced Mermaid block)
  Raw Mermaid: --format mermaid
  SVG: --format svg
`;
}

function getAuthHeader() {
  const token = process.env.JIRA_TOKEN;
  const email = process.env.JIRA_EMAIL || DEFAULT_JIRA_EMAIL;
  if (!token) {
    throw new Error("Missing Jira auth. Set JIRA_TOKEN.");
  }

  const basic = Buffer.from(`${email}:${token}`, "utf8").toString("base64");
  return `Basic ${basic}`;
}

function normalizeBaseUrl(rawBaseUrl) {
  const value = rawBaseUrl && rawBaseUrl.trim() ? rawBaseUrl : DEFAULT_JIRA_BASE_URL;
  return value.replace(/\/+$/, "");
}

async function jiraRequest(baseUrl, authHeader, path, params = {}) {
  const url = new URL(`${baseUrl}${path}`);
  for (const [key, value] of Object.entries(params)) {
    url.searchParams.set(key, String(value));
  }

  const response = await fetch(url, {
    headers: {
      Accept: "application/json",
      Authorization: authHeader,
    },
  });

  if (!response.ok) {
    const text = await response.text();
    const detail = text.length > 600 ? `${text.slice(0, 600)}...` : text;
    throw new Error(
      `Jira request failed (${response.status} ${response.statusText}) for ${url.pathname}: ${detail}`
    );
  }

  return response.json();
}

async function fetchIssue(baseUrl, authHeader, issueKey) {
  return jiraRequest(baseUrl, authHeader, `/rest/api/3/issue/${issueKey}`, {
    fields: "key,summary,issuetype,status,resolution",
  });
}

async function searchAllIssues(baseUrl, authHeader, jql, fields) {
  const all = [];
  let startAt = 0;
  const maxResults = 100;

  while (true) {
    const result = await jiraRequest(baseUrl, authHeader, "/rest/api/3/search/jql", {
      jql,
      fields: fields.join(","),
      startAt,
      maxResults,
    });

    const issues = result.issues || [];
    all.push(...issues);
    startAt += issues.length;

    if (startAt >= (result.total || 0) || issues.length === 0) {
      break;
    }
  }

  return all;
}

async function tryFindEpicChildren(baseUrl, authHeader, epicKey) {
  const fields = [
    "key",
    "summary",
    "issuetype",
    "issuelinks",
    "parent",
    "status",
    "resolution",
  ];
  const queries = [
    `parentEpic = ${epicKey}`,
    `"Epic Link" = ${epicKey}`,
    `parent = ${epicKey}`,
  ];

  const byKey = new Map();
  for (const jql of queries) {
    try {
      const issues = await searchAllIssues(baseUrl, authHeader, jql, fields);
      for (const issue of issues) {
        byKey.set(issue.key, issue);
      }
    } catch (error) {
      const message = String(error.message || "");
      // Some Jira instances don't support every epic-related JQL variant.
      if (
        message.includes("Jira request failed (400") ||
        message.toLowerCase().includes("field")
      ) {
        continue;
      }
      throw error;
    }
  }

  return Array.from(byKey.values());
}

function toNodeId(issueKey) {
  return `I_${issueKey.replace(/[^A-Za-z0-9_]/g, "_")}`;
}

function sanitizeLabel(text) {
  return String(text || "")
    // Mermaid node labels are brittle with escaped double quotes.
    .replace(/"/g, "'")
    .replace(/\r?\n/g, " ")
    .trim();
}

function isNotRequired(issue) {
  const statusName = String(issue.fields?.status?.name || "").toLowerCase();
  const resolutionName = String(issue.fields?.resolution?.name || "").toLowerCase();
  return statusName === "not required" || resolutionName === "not required";
}

function statusClass(issue) {
  const statusCategory = String(issue.fields?.status?.statusCategory?.name || "").toLowerCase();
  if (statusCategory === "done") {
    return "done";
  }
  if (statusCategory === "in progress") {
    return "inProgress";
  }
  return null;
}

function buildDependencyEdges(childIssues) {
  const childKeys = new Set(childIssues.map((issue) => issue.key));
  const seen = new Set();
  const edges = [];

  for (const issue of childIssues) {
    const current = issue.key;
    const links = issue.fields?.issuelinks || [];
    for (const link of links) {
      const outwardIssue = link.outwardIssue?.key;
      if (outwardIssue && childKeys.has(outwardIssue)) {
        const id = `${current}->${outwardIssue}`;
        if (!seen.has(id)) {
          seen.add(id);
          // Store as "is blocked by": blocked -> blocker.
          edges.push({ from: outwardIssue, to: current });
        }
      }

      const inwardIssue = link.inwardIssue?.key;
      if (inwardIssue && childKeys.has(inwardIssue)) {
        const id = `${inwardIssue}->${current}`;
        if (!seen.has(id)) {
          seen.add(id);
          // Store as "is blocked by": blocked -> blocker.
          edges.push({ from: current, to: inwardIssue });
        }
      }
    }
  }

  return edges;
}

function toMermaid(epicKey, childIssues, edges) {
  const lines = [];
  lines.push("graph BT");
  lines.push(`  %% Epic ${epicKey} child dependency map`);

  for (const issue of childIssues) {
    const nodeId = toNodeId(issue.key);
    const summary = sanitizeLabel(issue.fields?.summary || "");
    lines.push(`  ${nodeId}["${issue.key}: ${summary}"]`);
    const cls = statusClass(issue);
    if (cls) {
      lines.push(`  class ${nodeId} ${cls}`);
    }
  }

  if (edges.length > 0) {
    lines.push("  %% A --> B means A is blocked by B");
  }
  for (const edge of edges) {
    lines.push(`  ${toNodeId(edge.from)} --> ${toNodeId(edge.to)}`);
  }

  if (childIssues.some((issue) => statusClass(issue) === "done")) {
    lines.push("  classDef done stroke:#2e7d32,stroke-width:3px");
  }
  if (childIssues.some((issue) => statusClass(issue) === "inProgress")) {
    lines.push(
      "  classDef inProgress stroke:#2e7d32,stroke-width:3px,stroke-dasharray: 6 4"
    );
  }

  return `${lines.join("\n")}\n`;
}

function toMermaidMarkdown(mermaid) {
  return `\`\`\`mermaid\n${mermaid}\`\`\`\n`;
}

async function renderSvgFromMermaid(mermaid) {
  const mmdc = process.env.MERMAID_CLI || "mmdc";
  const workDir = await fs.mkdtemp(path.join(os.tmpdir(), "epicdeps-"));
  const inputPath = path.join(workDir, "graph.mmd");
  const outputPath = path.join(workDir, "graph.svg");

  try {
    await fs.writeFile(inputPath, mermaid, "utf8");
    await execFileAsync(mmdc, ["-i", inputPath, "-o", outputPath], {
      maxBuffer: 16 * 1024 * 1024,
    });
    return await fs.readFile(outputPath, "utf8");
  } catch (error) {
    if (error && error.code === "ENOENT") {
      throw new Error(
        "Mermaid CLI not found. Install mermaid-cli or set MERMAID_CLI to the mmdc binary."
      );
    }
    const stderr = String(error && error.stderr ? error.stderr : "").trim();
    throw new Error(stderr || String(error.message || error));
  } finally {
    await fs.rm(workDir, { recursive: true, force: true });
  }
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  if (args.help || !args.epicKey) {
    console.log(usage());
    process.exit(args.help ? 0 : 1);
  }

  const baseUrl = normalizeBaseUrl(process.env.JIRA_BASE_URL);
  const authHeader = getAuthHeader();

  await fetchIssue(baseUrl, authHeader, args.epicKey);
  const allChildren = await tryFindEpicChildren(baseUrl, authHeader, args.epicKey);
  const children = allChildren.filter(
    (issue) => issue.key !== args.epicKey && !isNotRequired(issue)
  );
  if (children.length === 0) {
    throw new Error(
      `No child issues found for epic ${args.epicKey}. Check permissions or JQL support.`
    );
  }

  children.sort((a, b) => a.key.localeCompare(b.key));
  const edges = buildDependencyEdges(children);
  const mermaid = toMermaid(args.epicKey, children, edges);
  let output;
  if (args.format === "svg") {
    output = await renderSvgFromMermaid(mermaid);
  } else if (args.format === "mermaid") {
    output = mermaid;
  } else {
    output = toMermaidMarkdown(mermaid);
  }

  if (args.output) {
    await fs.writeFile(args.output, output, "utf8");
    console.error(`Wrote ${args.format} output to ${args.output}`);
    return;
  }

  process.stdout.write(output);
}

main().catch((error) => {
  console.error(`Error: ${error.message}`);
  process.exit(1);
});
